<!DOCTYPE html>
<head>
<title>Turn Based Strategy</title>

<style type="text/css">
body{
    background-color: rgb(75, 75, 75);
}
#CellContainer{
    width: inherit;
    height: 200%;
    /*background-color: rgba(0, 255, 255, 0.233);*/
    position: absolute;
    
    
}
#CellContainer *{
    display: grid;
    float: left;
    /*margin-right: 1px;
    margin-bottom: 1px;*/
    
}
</style>

</head>

<body>
    <div id="Square" style="height:100%; background-color: rgb(0, 0, 0); z-index: -10; left: 0px;top: 0px; position: absolute;overflow: hidden;">
        <div id="CellContainer">

        </div>

<script>
    if(screen.width < screen.height){
        document.getElementById("Square").style.width = "100%"
    }else{
        document.getElementById("Square").style.width = "400px"
    }


BrownArray = []
let MovingWorker = 0
let BarracksFlag = false
let FarmFlag = false
class Worker{
    constructor(Health,Attack,Defense,Speed,Range,moveToX,moveToY){
        //Health,Attack,Defense,Speed,Range,x,y
        this.Health = Health
        this.Attack = Attack
        this.Defense = Defense
        this.Speed = Speed
        this.Range = Range  
        this.x = moveToX
        this.y = moveToY
        this.workQueue = [] //add the job to queue with name and coordinate
        this.MoveQueue = []
        this.Selected = false
    }
    Move(){
        
        
        if(this.MoveQueue.length > 0){
            var WorkerCell = document.getElementById("Cell,"+this.x+","+this.y)
            WorkerCell.style.backgroundColor = "grey"
            //console.log(this.x,this.y)
            grid[this.x][this.y] = 1
            //console.log(grid[this.x][this.y])
            WorkerCell.Selected = false
            this.Selected = false
            this.x = this.MoveQueue[this.MoveQueue.length-1][0]
            this.y = this.MoveQueue[this.MoveQueue.length-1][1]
            
            //document.getElementById("Cell,"+this.x+","+this.y).style.backgroundColor = "limegreen"
            if(this.MoveQueue.length == 1){
                
                console.log(document.getElementsByClassName("Red").length)
                while(document.getElementsByClassName("Red").length > 0){

                    document.getElementsByClassName("Red")[0].style.backgroundColor = "grey"
                    document.getElementsByClassName("Red")[0].className = "None"
                }
                this.DrawWorker(true)
            }
            else{
                this.DrawWorker()
            }
            
            
            this.MoveQueue.pop()
            
            MovingWorker = "Cell,"+this.x+","+this.y
            
            //grid[this.x][this.y] = 0
            
        }
    }
    DrawWorker(WorkerFlag = false){
        //grid[this.x][this.y] = 0
        //grid[10+i][12] = 0
        var WorkerCell = document.getElementById("Cell,"+this.x+","+this.y)
        grid[this.x][this.y] = 0
        if(this.Selected || MovingWorker == "Cell,"+this.x+","+this.y){
            WorkerCell.style.backgroundColor = "limegreen"
        }
        else{
            WorkerCell.style.backgroundColor = "Green"
        }
        var WorkerX = this.x;
        var WorkerY = this.y;
        var WorkerRange = this.Range;
        var WorkerSpeed = this.Speed;
        console.log(WorkerRange)
        if(WorkerFlag){
            WorkerCell.onclick = function WorkerClick(){
                //console.log("Call")
                console.log(this.style.backgroundColor,"ff")
                if(this.style.backgroundColor == "red"){
                    console.log(this.id.split(",")[1],this.id.split(",")[2])

                }
                else{

                
                for(let i = 0;i<WorkerArray.length;i++){
                    
                    document.getElementById("Cell,"+WorkerArray[i].x+","+WorkerArray[i].y).style.backgroundColor = "Green"

                }
                console.log(WorkerX)
                if(BrownArray.length > 0){
                    console.log(BrownArray[0])
                    while(BrownArray.length > 0){
                        BrownArray[0].style.backgroundColor = "grey"
                        BrownArray.shift()
                    }
                }
                for(let xi = -WorkerSpeed-WorkerRange;xi<=WorkerSpeed+WorkerRange;xi++){
                    for(let yi = -WorkerSpeed-WorkerRange;yi<=WorkerSpeed+WorkerRange;yi++){
                        try{
                        if(grid[xi+WorkerX][yi+WorkerY] == 1){
                            document.getElementById("Cell,"+(xi+WorkerX)+","+(yi+WorkerY)).style.backgroundColor = "brown"
                            var brownCell = document.getElementById("Cell,"+(xi+WorkerX)+","+(yi+WorkerY))
                            BrownArray.push(brownCell)

                        }
                        else if(document.getElementById("Cell,"+(xi+WorkerX)+","+(yi+WorkerY)).style.backgroundColor == "green"){
                            document.getElementById("Cell,"+(xi+WorkerX)+","+(yi+WorkerY)).style.backgroundColor = "red"
                        }

                    }catch{
                        console.log("pp")
                        }
                    }
                }
                for(let xi = -WorkerSpeed;xi<=WorkerSpeed;xi++){
                    for(let yi = -WorkerSpeed;yi<=WorkerSpeed;yi++){
                        try{
                        if(grid[xi+WorkerX][yi+WorkerY] == 1){
                            
                            document.getElementById("Cell,"+(xi+WorkerX)+","+(yi+WorkerY)).style.backgroundColor = "blue"
                            var brownCell = document.getElementById("Cell,"+(xi+WorkerX)+","+(yi+WorkerY))
                            BrownArray.push(brownCell)
                            

                        }
                    }catch{
                                console.log("pp")
                            }
                    }
                }
                WorkerCell.style.backgroundColor = "Limegreen"
                for(let i =0;i<WorkerArray.length;i++){
                    WorkerArray[i].Selected = false
                    //get x and y and change color back to green from limegreeen
                }
                this.Selected = true
                MovingWorker = this.id

            }
            }
        }
        else{
            WorkerCell.onclick = function cellOnclick(){
                cellOnClickFunction(this)
                
            }
        }
    }
}

    MovingCells = 0
let grid = []
function Setup(){
    num = parseInt(parseInt(document.getElementById("Square").style.width)/25)
    for(let i = 0;i<num;i++){
        row = []
        for(let j = 0;j<num;j++){
            Cell = document.createElement("div")
            Cell.id = "Cell,"+i+","+j
            Cell.style.width = "25px"
            Cell.style.height = "25px"
            Cell.style.position = "relative"
            //Cell.style.left = i*20+"px"
            //Cell.style.left = j*20+"px"
            Cell.style.backgroundColor = "grey"
            Cell.onmouseover = function cellHover(){
                
                
                

                
            }
            Cell.onmouseleave = function CellLeave(){
                

                
            }
            Cell.onclick = function cellOnclick(){
                cellOnClickFunction(this)
            }
            row.push(1)
            document.getElementById("CellContainer").appendChild(Cell)
        }
        grid.push(row)
    }
    for(let i = 0;i<5;i++){
        
        grid[3+i][5] = 0
        grid[10+i][12] = 0
        document.getElementById("Cell,"+(3+i)+","+5).style.backgroundColor = "black"
        document.getElementById("Cell,"+(10+i)+","+12).style.backgroundColor = "black"
    }
    WorkerArray = []
    //Health,Attack,Defense,Speed,Range,x,y
    OGWorker = new Worker(3,3,3,1,2,5,3)
    OGWorker2 = new Worker(3,3,3,3,1,8,5)
    OGWorker.DrawWorker(true)
    OGWorker2.DrawWorker(true)
    WorkerArray.push(OGWorker)
    WorkerArray.push(OGWorker2)

}
function cellOnClickFunction(This){
    if(MovingWorker != 0 && grid[This.id.split(",")[1]][This.id.split(",")[2]] == 1&&This.style.backgroundColor == "blue"){
        console.log(grid)
        if(BrownArray.length > 0){
            console.log(BrownArray[0])
            while(BrownArray.length > 0){
                BrownArray[0].style.backgroundColor = "grey"
                BrownArray.shift()
            }
        }
        for(let i = 0;i<WorkerArray.length;i++){
                    
            document.getElementById("Cell,"+WorkerArray[i].x+","+WorkerArray[i].y).style.backgroundColor = "Green"

        }
        This.style.backgroundColor = "Red"
        This.className = "Red"
        MovingCells = This.id
        //let grid = 
            MoveArray = aStarSearch(grid,([parseInt(MovingWorker.split(",")[1]),parseInt(MovingWorker.split(",")[2])]),([parseInt(This.id.split(",")[1]),parseInt(This.id.split(",")[2])]))//parseInt(MovingWorker.split(",")[1]),parseInt(MovingWorker.split(",")[2]),parseInt(This.id.split(",")[1]),parseInt(This.id.split(",")[2]))
        for(let worker = 0;worker<WorkerArray.length;worker++){
            if(WorkerArray[worker].x == MovingWorker.split(",")[1] && WorkerArray[worker].y == MovingWorker.split(",")[2]){
                WorkerArray[worker].MoveQueue = MoveArray
            }
        }
        /*for(let a = 1;a<MoveArray.length-1;a++){
        
            document.getElementById("Cell,"+MoveArray[a][0]+","+MoveArray[a][1]).style.backgroundColor = "yellow"
        }*/
    }
    

    
}
spawningArray = []
Setup()


const interval = setInterval(function() {
    for(let i = 0;i<WorkerArray.length;i++){
        WorkerArray[i].Move()
    }
}, 100);




let ROW = 100;
let COL = 100;

// typedef pair<double, pair<int, int> > pPair;

// A structure to hold the necessary parameters
class cell {
    // Row and Column index of its parent
    // Note that 0 <= i <= ROW-1 & 0 <= j <= COL-1
    constructor(){
        this.parent_i = 0;
        this.parent_j = 0;
        this.f = 0;
        this.g = 0;
        this.h = 0;
    }
}
// A Utility Function to check whether given cell (row, col)
// is a valid cell or not.
function isValid(row, col)
{
    // Returns true if row number and column number
    // is in range
    return (row >= 0) && (row < ROW) && (col >= 0) && (col < COL);
}

// A Utility Function to check whether the given cell is
// blocked or not
function isUnBlocked(grid, row, col)
{
    // Returns true if the cell is not blocked else false
    if (grid[row][col] == 1)
        return (true);
    else
        return (false);
}

// A Utility Function to check whether destination cell has
// been reached or not
function isDestination(row, col, dest)
{
    if (row == dest[0] && col == dest[1])
        return (true);
    else
        return (false);
}

// A Utility Function to calculate the 'h' heuristics.
function calculateHValue(row, col, dest)
{
    // Return using the distance formula
    return (Math.sqrt((row - dest[0]) * (row - dest[0]) + (col - dest[1]) * (col - dest[1])));
}

// A Utility Function to trace the path from the source
// to destination
function tracePath(cellDetails, dest)
{
    console.log("The Path is ");
    let row = dest[0];
    let col = dest[1];

    // stack<Pair> Path;
    let Path = [];

    while (!(cellDetails[row][col].parent_i == row && cellDetails[row][col].parent_j == col)) {
        Path.push([row, col]);
        let temp_row = cellDetails[row][col].parent_i;
        let temp_col = cellDetails[row][col].parent_j;
        row = temp_row;
        col = temp_col;
    }

    Path.push([row, col]);
    //console.log(Path[0])
    
    tempPath = []
    while (Path.length > 0) {
        let p = Path[0];
        Path.shift();
        
        if(p[0] == 2 || p[0] == 1){
            console.log("-> (" + p[0] + ", " + (p[1] - 1) + ")");
            tempPath.push([p[0],(p[1] - 1)])
        }
        else {console.log("-> (" + p[0] + ", " + p[1] + ")");tempPath.push([p[0],(p[1])]);}
    }
    console.log(tempPath)
    return tempPath;
}

// A Function to find the shortest path between
// a given source cell to a destination cell according
// to A* Search Algorithm
function aStarSearch(grid, src, dest)
{
    // If the source is out of range
    if (isValid(src[0], src[1]) == false) {
        console.log("Source is invalid\n");
        return;
    }

    // If the destination is out of range
    if (isValid(dest[0], dest[1]) == false) {
        console.log("Destination is invalid\n");
        return;
    }

    // Either the source or the destination is blocked
    /*if (isUnBlocked(grid, src[0], src[1]) == false
        || isUnBlocked(grid, dest[0], dest[1])
               == false) {
        console.log("Source or the destination is blocked\n");
        return;
    }*/

    // If the destination cell is the same as source cell
    if (isDestination(src[0], src[1], dest)
        == true) {
        console.log("We are already at the destination\n");
        return;
    }

    // Create a closed list and initialise it to false which
    // means that no cell has been included yet This closed
    // list is implemented as a boolean 2D array
    let closedList = new Array(ROW);
    for(let i = 0; i < ROW; i++){
        closedList[i] = new Array(COL).fill(false);
    }

    // Declare a 2D array of structure to hold the details
    // of that cell
    let cellDetails = new Array(ROW);
    for(let i = 0; i < ROW; i++){
        cellDetails[i] = new Array(COL);
    }

    let i, j;

    for (i = 0; i < ROW; i++) {
        for (j = 0; j < COL; j++) {
            cellDetails[i][j] = new cell();
            cellDetails[i][j].f = 2147483647;
            cellDetails[i][j].g = 2147483647;
            cellDetails[i][j].h = 2147483647;
            cellDetails[i][j].parent_i = -1;
            cellDetails[i][j].parent_j = -1;
        }
    }

    // Initialising the parameters of the starting node
    i = src[0], j = src[1];
    cellDetails[i][j].f = 0;
    cellDetails[i][j].g = 0;
    cellDetails[i][j].h = 0;
    cellDetails[i][j].parent_i = i;
    cellDetails[i][j].parent_j = j;

    /*
     Create an open list having information as-
     <f, <i, j>>
     where f = g + h,
     and i, j are the row and column index of that cell
     Note that 0 <= i <= ROW-1 & 0 <= j <= COL-1
     This open list is implemented as a set of pair of
     pair.*/
    let openList = new Map();

    // Put the starting cell on the open list and set its
    // 'f' as 0
    openList.set(0, [i, j]);

    // We set this boolean value as false as initially
    // the destination is not reached.
    let foundDest = false;

    while (openList.size > 0) {
        let p = openList.entries().next().value

        // Remove this vertex from the open list
        openList.delete(p[0]);

        // Add this vertex to the closed list
        i = p[1][0];
        j = p[1][1];
        closedList[i][j] = true;

        

        // To store the 'g', 'h' and 'f' of the 8 successors
        let gNew, hNew, fNew;

        //----------- 1st Successor (North) ------------

        // Only process this cell if this is a valid one
        if (isValid(i - 1, j) == true) {
            // If the destination cell is the same as the
            // current successor
            if (isDestination(i - 1, j, dest) == true) {
                // Set the Parent of the destination cell
                cellDetails[i - 1][j].parent_i = i;
                cellDetails[i - 1][j].parent_j = j;
                console.log("The destination cell is found\n");
                Path = tracePath(cellDetails, dest);
                foundDest = true;
                return Path;
            }
            // If the successor is already on the closed
            // list or if it is blocked, then ignore it.
            // Else do the following
            else if (closedList[i - 1][j] == false
                     && isUnBlocked(grid, i - 1, j)
                            == true) {
                gNew = cellDetails[i][j].g + 1;
                hNew = calculateHValue(i - 1, j, dest);
                fNew = gNew + hNew;

                // If it isn’t on the open list, add it to
                // the open list. Make the current square
                // the parent of this square. Record the
                // f, g, and h costs of the square cell
                //                OR
                // If it is on the open list already, check
                // to see if this path to that square is
                // better, using 'f' cost as the measure.
                if (cellDetails[i - 1][j].f == 2147483647
                    || cellDetails[i - 1][j].f > fNew) {
                    openList.set(fNew, [i - 1, j]);

                    // Update the details of this cell
                    cellDetails[i - 1][j].f = fNew;
                    cellDetails[i - 1][j].g = gNew;
                    cellDetails[i - 1][j].h = hNew;
                    cellDetails[i - 1][j].parent_i = i;
                    cellDetails[i - 1][j].parent_j = j;
                }
            }
        }

        //----------- 2nd Successor (South) ------------

        // Only process this cell if this is a valid one
        if (isValid(i + 1, j) == true) {
            // If the destination cell is the same as the
            // current successor
            if (isDestination(i + 1, j, dest) == true) {
                // Set the Parent of the destination cell
                cellDetails[i + 1][j].parent_i = i;
                cellDetails[i + 1][j].parent_j = j;
                console.log("The destination cell is found\n");
                Path = tracePath(cellDetails, dest);
                foundDest = true;
                return Path;
            }
            // If the successor is already on the closed
            // list or if it is blocked, then ignore it.
            // Else do the following
            else if (closedList[i + 1][j] == false
                     && isUnBlocked(grid, i + 1, j)
                            == true) {
                gNew = cellDetails[i][j].g + 1;
                hNew = calculateHValue(i + 1, j, dest);
                fNew = gNew + hNew;

                // If it isn’t on the open list, add it to
                // the open list. Make the current square
                // the parent of this square. Record the
                // f, g, and h costs of the square cell
                //                OR
                // If it is on the open list already, check
                // to see if this path to that square is
                // better, using 'f' cost as the measure.
                if (cellDetails[i + 1][j].f == 2147483647
                    || cellDetails[i + 1][j].f > fNew) {
                    openList.set(fNew, [i + 1, j]);
                    // Update the details of this cell
                    cellDetails[i + 1][j].f = fNew;
                    cellDetails[i + 1][j].g = gNew;
                    cellDetails[i + 1][j].h = hNew;
                    cellDetails[i + 1][j].parent_i = i;
                    cellDetails[i + 1][j].parent_j = j;
                }
            }
        }

        //----------- 3rd Successor (East) ------------

        // Only process this cell if this is a valid one
        if (isValid(i, j + 1) == true) {
            // If the destination cell is the same as the
            // current successor
            if (isDestination(i, j + 1, dest) == true) {
                // Set the Parent of the destination cell
                cellDetails[i][j + 1].parent_i = i;
                cellDetails[i][j + 1].parent_j = j;
                console.log("The destination cell is found\n");
                Path = tracePath(cellDetails, dest);
                foundDest = true;
                return Path;
            }

            // If the successor is already on the closed
            // list or if it is blocked, then ignore it.
            // Else do the following
            else if (closedList[i][j + 1] == false
                     && isUnBlocked(grid, i, j + 1)
                            == true) {
                gNew = cellDetails[i][j].g + 1;
                hNew = calculateHValue(i, j + 1, dest);
                fNew = gNew + hNew;

                // If it isn’t on the open list, add it to
                // the open list. Make the current square
                // the parent of this square. Record the
                // f, g, and h costs of the square cell
                //                OR
                // If it is on the open list already, check
                // to see if this path to that square is
                // better, using 'f' cost as the measure.
                if (cellDetails[i][j + 1].f == 2147483647
                    || cellDetails[i][j + 1].f > fNew) {
                    openList.set(fNew, [i, j + 1]);

                    // Update the details of this cell
                    cellDetails[i][j + 1].f = fNew;
                    cellDetails[i][j + 1].g = gNew;
                    cellDetails[i][j + 1].h = hNew;
                    cellDetails[i][j + 1].parent_i = i;
                    cellDetails[i][j + 1].parent_j = j;
                }
            }
        }

        //----------- 4th Successor (West) ------------

        // Only process this cell if this is a valid one
        if (isValid(i, j - 1) == true) {
            // If the destination cell is the same as the
            // current successor
            if (isDestination(i, j - 1, dest) == true) {
                // Set the Parent of the destination cell
                cellDetails[i][j - 1].parent_i = i;
                cellDetails[i][j - 1].parent_j = j;
                console.log("The destination cell is found\n");
                Path = tracePath(cellDetails, dest);
                foundDest = true;
                return Path;
            }

            // If the successor is already on the closed
            // list or if it is blocked, then ignore it.
            // Else do the following
            else if (closedList[i][j - 1] == false
                     && isUnBlocked(grid, i, j - 1)
                            == true) {
                gNew = cellDetails[i][j].g + 1;
                hNew = calculateHValue(i, j - 1, dest);
                fNew = gNew + hNew;

                // If it isn’t on the open list, add it to
                // the open list. Make the current square
                // the parent of this square. Record the
                // f, g, and h costs of the square cell
                //                OR
                // If it is on the open list already, check
                // to see if this path to that square is
                // better, using 'f' cost as the measure.
                if (cellDetails[i][j - 1].f == 2147483647
                    || cellDetails[i][j - 1].f > fNew) {
                    openList.set(fNew, [i, j - 1]);

                    // Update the details of this cell
                    cellDetails[i][j - 1].f = fNew;
                    cellDetails[i][j - 1].g = gNew;
                    cellDetails[i][j - 1].h = hNew;
                    cellDetails[i][j - 1].parent_i = i;
                    cellDetails[i][j - 1].parent_j = j;
                }
            }
        }

        //----------- 5th Successor (North-East)
        //------------

        // Only process this cell if this is a valid one
        if (isValid(i - 1, j + 1) == true) {
            // If the destination cell is the same as the
            // current successor
            if (isDestination(i - 1, j + 1, dest) == true) {
                // Set the Parent of the destination cell
                cellDetails[i - 1][j + 1].parent_i = i;
                cellDetails[i - 1][j + 1].parent_j = j;
                console.log("The destination cell is found\n");
                Path = tracePath(cellDetails, dest);
                foundDest = true;
                return Path;
            }

            // If the successor is already on the closed
            // list or if it is blocked, then ignore it.
            // Else do the following
            else if (closedList[i - 1][j + 1] == false
                     && isUnBlocked(grid, i - 1, j + 1)
                            == true) {
                gNew = cellDetails[i][j].g + 1.414;
                hNew = calculateHValue(i - 1, j + 1, dest);
                fNew = gNew + hNew;

                // If it isn’t on the open list, add it to
                // the open list. Make the current square
                // the parent of this square. Record the
                // f, g, and h costs of the square cell
                //                OR
                // If it is on the open list already, check
                // to see if this path to that square is
                // better, using 'f' cost as the measure.
                if (cellDetails[i - 1][j + 1].f == 2147483647
                    || cellDetails[i - 1][j + 1].f > fNew) {
                    openList.set(fNew, [i - 1, j + 1]);

                    // Update the details of this cell
                    cellDetails[i - 1][j + 1].f = fNew;
                    cellDetails[i - 1][j + 1].g = gNew;
                    cellDetails[i - 1][j + 1].h = hNew;
                    cellDetails[i - 1][j + 1].parent_i = i;
                    cellDetails[i - 1][j + 1].parent_j = j;
                }
            }
        }

        //----------- 6th Successor (North-West)
        //------------

        // Only process this cell if this is a valid one
        if (isValid(i - 1, j - 1) == true) {
            // If the destination cell is the same as the
            // current successor
            if (isDestination(i - 1, j - 1, dest) == true) {
                // Set the Parent of the destination cell
                cellDetails[i - 1][j - 1].parent_i = i;
                cellDetails[i - 1][j - 1].parent_j = j;
                console.log("The destination cell is found\n");
                Path = tracePath(cellDetails, dest);
                foundDest = true;
                return Path;
            }

            // If the successor is already on the closed
            // list or if it is blocked, then ignore it.
            // Else do the following
            else if (closedList[i - 1][j - 1] == false
                     && isUnBlocked(grid, i - 1, j - 1)
                            == true) {
                gNew = cellDetails[i][j].g + 1.414;
                hNew = calculateHValue(i - 1, j - 1, dest);
                fNew = gNew + hNew;

                // If it isn’t on the open list, add it to
                // the open list. Make the current square
                // the parent of this square. Record the
                // f, g, and h costs of the square cell
                //                OR
                // If it is on the open list already, check
                // to see if this path to that square is
                // better, using 'f' cost as the measure.
                if (cellDetails[i - 1][j - 1].f == 2147483647
                    || cellDetails[i - 1][j - 1].f > fNew) {
                    openList.set(fNew, [i - 1, j - 1]);
                    // Update the details of this cell
                    cellDetails[i - 1][j - 1].f = fNew;
                    cellDetails[i - 1][j - 1].g = gNew;
                    cellDetails[i - 1][j - 1].h = hNew;
                    cellDetails[i - 1][j - 1].parent_i = i;
                    cellDetails[i - 1][j - 1].parent_j = j;
                }
            }
        }

        //----------- 7th Successor (South-East)
        //------------

        // Only process this cell if this is a valid one
        if (isValid(i + 1, j + 1) == true) {
            // If the destination cell is the same as the
            // current successor
            if (isDestination(i + 1, j + 1, dest) == true) {
                // Set the Parent of the destination cell
                cellDetails[i + 1][j + 1].parent_i = i;
                cellDetails[i + 1][j + 1].parent_j = j;
                console.log("The destination cell is found\n");
                Path = tracePath(cellDetails, dest);
                foundDest = true;
                return Path;
            }

            // If the successor is already on the closed
            // list or if it is blocked, then ignore it.
            // Else do the following
            else if (closedList[i + 1][j + 1] == false
                     && isUnBlocked(grid, i + 1, j + 1)
                            == true) {
                gNew = cellDetails[i][j].g + 1.414;
                hNew = calculateHValue(i + 1, j + 1, dest);
                fNew = gNew + hNew;

                // If it isn’t on the open list, add it to
                // the open list. Make the current square
                // the parent of this square. Record the
                // f, g, and h costs of the square cell
                //                OR
                // If it is on the open list already, check
                // to see if this path to that square is
                // better, using 'f' cost as the measure.
                if (cellDetails[i + 1][j + 1].f == 2147483647
                    || cellDetails[i + 1][j + 1].f > fNew) {
                    openList.set(fNew, [i + 1, j + 1]);

                    // Update the details of this cell
                    cellDetails[i + 1][j + 1].f = fNew;
                    cellDetails[i + 1][j + 1].g = gNew;
                    cellDetails[i + 1][j + 1].h = hNew;
                    cellDetails[i + 1][j + 1].parent_i = i;
                    cellDetails[i + 1][j + 1].parent_j = j;
                }
            }
        }

        //----------- 8th Successor (South-West)
        //------------

        // Only process this cell if this is a valid one
        if (isValid(i + 1, j - 1) == true) {
            // If the destination cell is the same as the
            // current successor
            if (isDestination(i + 1, j - 1, dest) == true) {
                // Set the Parent of the destination cell
                cellDetails[i + 1][j - 1].parent_i = i;
                cellDetails[i + 1][j - 1].parent_j = j;
                console.log("The destination cell is found\n");
                Path = tracePath(cellDetails, dest);
                foundDest = true;
                return Path;
            }

            // If the successor is already on the closed
            // list or if it is blocked, then ignore it.
            // Else do the following
            else if (closedList[i + 1][j - 1] == false
                     && isUnBlocked(grid, i + 1, j - 1)
                            == true) {
                gNew = cellDetails[i][j].g + 1.414;
                hNew = calculateHValue(i + 1, j - 1, dest);
                fNew = gNew + hNew;

                // If it isn’t on the open list, add it to
                // the open list. Make the current square
                // the parent of this square. Record the
                // f, g, and h costs of the square cell
                //                OR
                // If it is on the open list already, check
                // to see if this path to that square is
                // better, using 'f' cost as the measure.
                FLT_MAX = 1000000000
                if (cellDetails[i + 1][j - 1].f == FLT_MAX
                    || cellDetails[i + 1][j - 1].f > fNew) {
                    openList.set(fNew, [i + 1, j - 1]);

                    // Update the details of this cell
                    cellDetails[i + 1][j - 1].f = fNew;
                    cellDetails[i + 1][j - 1].g = gNew;
                    cellDetails[i + 1][j - 1].h = hNew;
                    cellDetails[i + 1][j - 1].parent_i = i;
                    cellDetails[i + 1][j - 1].parent_j = j;
                }
            }
        }
    }

    // When the destination cell is not found and the open
    // list is empty, then we conclude that we failed to
    // reach the destination cell. This may happen when the
    // there is no way to destination cell (due to
    // blockages)
    if (foundDest == false)
        console.log("Failed to find the Destination Cell\n");

    return Path;
}



</script>
</body>